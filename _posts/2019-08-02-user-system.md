---
layout: post
title: 用户系统设计
date: 2019-08-02 11:32:20
description: user system
img: i-rest.jpg
tags: [blog]
---
用户系统，用户缓存用户数据，定时存储，提高业务层数据效率，降低数据库负载而设计

## 预期
1. 业务路由，使节点更符合层的业务实现
2. 用户数据缓存，可为数据库降低消耗
3. 用户行为管理，业务综合到用户进程，数据并发性降低
4. 进程消耗降低，将会降低网关层和业务层的进程开辟量，转而使用常驻进程
5. 节点或业务节点扩展更灵活，数据聚合管理和散列管理，更容易实现。

## 考虑
1. 用户进程是否常驻
用户进程可以常驻，也可以不用常驻，在不常驻的情况下，只需要用户系统知道用户
应该在哪台节点上处理自己的业务就可以了。

2. 会话进程进行消息路由，如果确认目标，有三种方案
 - 可以将目标进程存放在会话进程（需要维护进程状态）
 - 可以将目标节点存放在会话进程（如果接收者是固定名称进程）
 - 可以通过第三方管理器获取目标进程 （考虑获取过程的通信或其他消耗）

2. 用户缓存
多个用户系统进程，还是只需要一个。
只有一个的消息量可能有点大。

4. 回档问题
 - 做了缓存定时存储就会回档，实时存储又会带来对数据库的负载。
 - 解决办法就是本地存储，延迟推送，或者缓存备份
 - 多一次通信和多一份内存，单节点就不行了
考虑下来采用本地存储（由于我们用的是Erlang所以可以直接采用Dets）
在数据组织上，可以每个玩家一个dets；也可以每个缓存字段一个dets。
如果每个玩家一个dets则多一份文件句柄，则可能有数千个，如果每个字段一个则可能只有数百个。
但问题是，都操作一个dets可能造成并发和较大的性能消耗。
 - dets需要一定的修复时间，所以表不宜太多

5. 统一操作模块
 - 在操作模块不统一的情况下，通用模块代码比较难维护


6. 确认缓存位置策略
 - 在缓存位置不能确认的情况下，事务很难做


## 结论
1. 取消用户进程常驻的概念，
 - 编程概念相对简单，不用围绕着用户进程
 - 不用维护用户进程状态和做容灾处理
 - 保障用户消息串行处理，接收消息进程需要排队处理用户消息

2. 数据可能交叉访问
 - 理想一个组的数据在一起，但性能无法满足时只有分散管理
 - 提供统一的访问接口，本地节点读取和远程节点读取

4. 提供事务或锁机制
 - 数据分为：系统数据、功能数据、用户数据 可能造成操作并发（用户消息串行只保障了一部分）。
 
5. 路由消息失败后处理
 - 异常后处理，因为发消息也可能异常，成功发消息后也可能异常，用户进程挂了，或user_system挂了 ，绑在session上的pid就要更新


## 数据缓存还是整存
散列带来了很多问题

1. 设计上不能和数据库表一一对应
2. 操作过程中，有时用到散列的域名，有时用到整存的表名做key
3. 存储风险变高,要统一接口很难做

我们后面又考虑了面向用户缓存，还是面向表缓存。

1. 面向表缓存更天然，不用处理关系
2. 面向表缓存，可以直接通过表名进行一次查询，不用先通过用户id判断数据在什么位置
3. 面向表缓存，数量更可控

## 如果面向表缓存
1. 每个表一个进程，并维护自身的数据库锁实现，锁会很多不会只有一个role
2. 锁标记的效率会降低，因为会向多个进程通信
3. 功能对单项数据遍历操作的时候，可以一次性拿完
4. 最大的为在于无法定位数据存在

## 面向用户的设计思路
1. 用户业务，通过一个事务进行数据管理
2. 用户事务，因由用户自身发起，或者对用户的完整操作
3. 系统同时锁多个用户，和轮询处理每个用户，我倾向后种

## 需求特性
在选择面向用户和面向表时，考虑到项目的数据趋近于纯单机，所以面向用户有所偏向