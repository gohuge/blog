---
layout: post
title: 用户系统设计
date: 2019-08-02 11:32:20
description: user system
img: i-rest.jpg
tags: [blog]
---
用户系统，用户缓存用户数据，定时存储，提高业务层数据效率，降低数据库负载而设计

## 预期
1. 业务路由，使节点更符合层的业务实现
2. 用户数据缓存，可为数据库降低消耗
3. 用户行为管理，业务综合到用户进程，数据并发性降低
4. 进程消耗降低，将会降低网关层和业务层的进程开辟量，转而使用常驻进程
5. 节点或业务节点扩展更灵活，数据聚合管理和散列管理，更容易实现。

## 考虑
1. 用户进程是否常驻
用户进程可以常驻，也可以不用常驻，在不常驻的情况下，只需要用户系统知道用户
应该在哪台节点上处理自己的业务就可以了。

2. 会话进程进行消息路由，如果确认目标，有三种方案
 - 可以将目标进程存放在会话进程（需要维护进程状态）
 - 可以将目标节点存放在会话进程（如果接收者是固定名称进程）
 - 可以通过第三方管理器获取目标进程 （考虑获取过程的通信或其他消耗）

2. 用户缓存
多个用户系统进程，还是只需要一个。
只有一个的消息量可能有点大。

4. 回档问题
 - 做了缓存定时存储就会回档，实时存储又会带来对数据库的负载。
 - 解决办法就是本地存储，延迟推送，或者缓存备份
 - 多一次通信和多一份内存，单节点就不行了
考虑下来采用本地存储（由于我们用的是Erlang所以可以直接采用Dets）
在数据组织上，可以每个玩家一个dets；也可以每个缓存字段一个dets。
如果每个玩家一个dets则多一份文件句柄，则可能有数千个，如果每个字段一个则可能只有数百个。
但问题是，都操作一个dets可能造成并发和较大的性能消耗。
 - dets需要一定的修复时间，所以表不宜太多

## 结论
1. 取消用户进程常驻的概念，
 - 编程概念相对简单，不用围绕着用户进程
 - 不用维护用户进程状态和做容灾处理
 - 保障用户消息串行处理，接收消息进程需要排队处理用户消息

2. 数据可能交叉访问
 - 理想一个组的数据在一起，但性能无法满足时只有分散管理
 - 提供统一的访问接口，本地节点读取和远程节点读取

4. 提供事务或锁机制
 - 数据分为：系统数据、功能数据、用户数据 可能造成操作并发（用户消息串行只保障了一部分）。
 
5. 路由消息失败后处理
 - 异常后处理，因为发消息也可能异常，成功发消息后也可能异常，用户进程挂了，或user_system挂了 ，绑在session上的pid就要更新